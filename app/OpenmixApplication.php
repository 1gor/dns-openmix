<?php

/**
 * For information on writing Openmix applications, check out
 * https://github.com/cedexis/openmixapplib/wiki
 */
class OpenmixApplication implements Lifecycle
{
    // Map provider aliases to cnames
    public $cnames = array(
        'cdn_net' => '531151672.r.worldcdn.net',
        'maxcdn' => 'jsdelivr3.dak.netdna-cdn.com',
        'leap-pt' => 'leap-pt.jsdelivr.net',
        'leap-ua' => 'leap-ua.jsdelivr.net',
        'prome-it' => 'prome-it.jsdelivr.net',
        'exvm-sg' => 'exvm-sg.jsdelivr.net',
        'jack-it' => 'jack-it.jsdelivr.net',
        'knight-nl' => 'knight-nl.jsdelivr.net',
        'alpine-ch' => 'alpine-ch.jsdelivr.net',
        'jetdi-id' => 'jetdi-id.jsdelivr.net',
        'finn-fr' => 'finn-fr.jsdelivr.net',
    );

    // If you add or subtract any public providers, update these!
    public $default_providers = array( 'maxcdn', 'cdn_net' );

    // The most likely to be available; selected as a last resort only
    public $last_resort_provider = 'maxcdn';

    // ASNs mapped to an array of one or more provider aliases.
    //
    // ASN overrides should only be necessary if you want a different subpopulation
    // of providers to be considered than those specified by $default_providers or
    // in $country_overrides.
    //
    // It should do no harm to include the public providers for consideration,
    // so these overrides should generally be used to create supersets that include
    // the default providers.
    public $asn_overrides = array(
        '42473' => array( 'prome-it', 'maxcdn' ), // cdn_net seems unfairly favored here
        //'25137' => array( 'leap-pt', 'maxcdn', 'cdn_net' ), // Portugal pingdom (handled at the country level)
        //'32489' => array( 'maxcdn', 'cdn_net' ), // Toronto pingdom (handled by the default)
        //'17090' => array( 'maxcdn', 'cdn_net' ), // Philadelphia 2, PA (handled by the default)
        //'32613' => array( 'maxcdn', 'cdn_net' ), // Montreal, Canada (handled by the default)
        //'49367' => array( 'prome-it', 'maxcdn', 'cdn_net' ), // Italy Milan (handled at the country level)
        //'39605' => array( 'maxcdn', 'cdn_net' ), // Paris France (handled by the default)
        //'8972' => array( 'maxcdn', 'cdn_net' ), // Strasbourg France (handled by the default)
        //'16265' => array( 'maxcdn', 'cdn_net' ), // Amsterdam (handled by the default)
        //'36351' => array( 'maxcdn', 'cdn_net' ), // San Jose (handled by the default)
        //'36114' => array( 'maxcdn', 'cdn_net' ), // Las Vegas 2 (handled by the default)
        //'30736' => array( 'maxcdn', 'cdn_net' ), // Denmark (handled by the default)
    );

    // country codes mapped to an array of one or more provider aliases
    //
    // ref: http://en.wikipedia.org/wiki/ISO_3166-1
    //
    // It should do no harm to include the public providers for consideration,
    // so these overrides should generally be used to create supersets that include
    // the default providers
    public $country_overrides = array(
        'IN' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'SG' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'MY' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'HK' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'CN' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'UA' => array( 'leap-ua', 'maxcdn', 'cdn_net' ),
        'PT' => array( 'leap-pt', 'maxcdn', 'cdn_net' ),
        'TH' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'AT' => array( 'prome-it', 'maxcdn', 'cdn_net' ),
        'KR' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'ID' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),
        'VN' => array( 'exvm-sg', 'maxcdn', 'cdn_net' ),

        // Generated by ../tools/gen_country_overrides.py --min-per-minute 2 --min-percent 50
        'BR' => array( 'maxcdn', 'cdn_net', 'finn-fr', 'leap-ua', 'exvm-sg', 'alpine-ch', 'prome-it', 'leap-pt', 'knight-nl', 'jetdi-id' ),
        'DE' => array( 'maxcdn', 'cdn_net', 'alpine-ch', 'knight-nl', 'finn-fr', 'jetdi-id' ),
        'IT' => array( 'maxcdn', 'cdn_net', 'finn-fr', 'leap-ua', 'alpine-ch', 'prome-it', 'leap-pt', 'knight-nl' ),
        'US' => array( 'maxcdn', 'cdn_net', 'finn-fr', 'leap-ua', 'exvm-sg', 'alpine-ch', 'prome-it', 'leap-pt', 'knight-nl', 'jetdi-id' ),
        'AU' => array( 'maxcdn', 'cdn_net', 'finn-fr', 'leap-ua', 'exvm-sg', 'alpine-ch', 'prome-it', 'leap-pt', 'knight-nl', 'jetdi-id' ),
        'MX' => array( 'maxcdn', 'cdn_net', 'alpine-ch' ),
        'CA' => array( 'maxcdn', 'cdn_net', 'finn-fr', 'leap-ua', 'exvm-sg', 'alpine-ch', 'prome-it', 'leap-pt', 'knight-nl', 'jetdi-id' ),
        'GB' => array( 'maxcdn', 'cdn_net', 'finn-fr', 'leap-ua', 'exvm-sg', 'alpine-ch', 'prome-it', 'leap-pt', 'knight-nl', 'jetdi-id' ),
    );

    // The thresholds (%) below which we consider a CDN unavailable
    public $availability_threshold = 90;
    public $sonar_threshold = 90;
    public $min_valid_rtt = 10;
    public $ttl = 20;
    
    public $reasons = array(
        'A', // RTT
        'B', // Country override
        'C', // ASN override
        'D', // Single available candidate
        'E', // None available
        'F', // No RTT data for available candidates
    );
    
    /**
     * @param Configuration $config
     **/
    public function init($config)
    {
        foreach ($this->cnames as $alias => $cname) {
            $config->declareResponseOption($alias, $cname, $this->ttl);
        }

        foreach ($this->reasons as $code) {
            $config->declareReasonCode($code);
        }

        // Only consider availability data for public providers
        $config->declareInput(RadarProbeTypes::AVAILABILITY, implode(',', $this->default_providers));

        $config->declareInput(RadarProbeTypes::HTTP_RTT, implode(',', array_keys($this->cnames)));
        $config->declareInput(PulseProperties::SONAR, implode(',', array_keys($this->cnames)));
        $config->declareInput(GeoProperties::COUNTRY);
        $config->declareInput(GeoProperties::ASN);
        $config->declareInput(EDNSProperties::ENABLE);
        $config->declareInput(EDNSProperties::COUNTRY);
        $config->declareInput(EDNSProperties::ASN);
    }
    
    /**
     * @param Request $request
     * @param Response $response
     * @param Utilities $utilities
     **/
    public function service($request, $response, $utilities)
    {
        $asn = $request->geo(GeoProperties::ASN);
        $country = $request->geo(GeoProperties::COUNTRY);
        if ($request->geo(EDNSProperties::ENABLE)) {
            $asn = $request->geo(EDNSProperties::ASN);
            $country = $request->geo(EDNSProperties::COUNTRY);
        }
        //print("\nASN: $asn");
        //print("\nCountry: $country");
        
        $avail = $request->radar(RadarProbeTypes::AVAILABILITY);
        $sonar = $request->pulse(PulseProperties::SONAR);
        //print("\nAvail:" . print_r($avail, true));
        //print("\nSonar:" . print_r($sonar, true));

        // Identify subpopulation
        $subpopulation = $this->default_providers;
        if (array_key_exists($asn, $this->asn_overrides)) {
            $subpopulation = $this->asn_overrides[$asn];
        }
        elseif (array_key_exists($country, $this->country_overrides)) {
            $subpopulation = $this->country_overrides[$country];
        }
        //print("\nSubpopulation:" . print_r($subpopulation, true));

        $candidates = array();
        foreach ($subpopulation as $alias) {
            $good = true;
            if (array_key_exists($alias, $avail)) {
                $value = $avail[$alias];
                if ($value < $this->availability_threshold) {
                    $good = false;
                }
            }
            
            if ($good && array_key_exists($alias, $sonar)) {
                $value = $sonar[$alias];
                if ($value < $this->sonar_threshold) {
                    $good = false;
                }
            }
            
            if ($good) {
                array_push($candidates, $alias);
            }
        }
        //print("\nCandidates:" . print_r($candidates, true));

        // If there's only one available candidate, just select it
        if (1 == count($candidates)) {
            $response->selectProvider($candidates[0]);
            $response->setReasonCode('D');
            return;
        }
        elseif (0 == count($candidates)) {
            // No providers available -- this should be rare
            $response->selectProvider($this->last_resort_provider);
            $response->setReasonCode('E');
            return;
        }
        
        // We should get to this point most of the time
        $rtt = $request->radar(RadarProbeTypes::HTTP_RTT);
        //print("\nRTT:" . print_r($rtt, true));
        $rtt = array_filter($rtt, array($this, 'got_rtt'));
        //print("\nRTT (filtered on got_rtt):" . print_r($rtt, true));
        $rtt = array_intersect_key($rtt, array_flip($candidates));
        //print("\nRTT (for candidates):" . print_r($rtt, true));

        if (0 == count($rtt)) {
            // No valid RTT data -- this should be rare
            $response->selectProvider($this->last_resort_provider);
            $response->setReasonCode('F');
            return;
        }

        asort($rtt);
        //print("\nRTT (sorted):" . print_r($rtt, true));
        $response->selectProvider(key($rtt));
        $response->setReasonCode('A');
    }

    public function got_rtt($score) {
        //print("\nScore: $score");
        return $score >= $this->min_valid_rtt;
    }
}

?>